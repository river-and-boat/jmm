## 从volatile看JAVA内存模型
### 前言
    作为一名刚毕业加入TW半年的应届生，由于自己以前读书时都是用C#，没有写过JAVA代码，更没有写过安卓，因此对整个安卓的学习路线一直感到迷惑，
    还好有全世界最好的buddy，项目上不断帮助自己，给自己反馈的小伙伴，以及技术架构都在天花板上的sponsor对自己无微不至的照顾。
    这篇文章是在系统学习JAVA多线程时，自己看书、看博客后的一些对JMM的思考，有不对的地方欢迎大家指出讨论，学无止境。

### 抛出问题
    在我们编写多线程代码时，我们可能会有这样的需求：
    我们希望线程A控制线程B代码的执行逻辑，即，我们在线程A中对一个标识位进行修改，如果标识位为true，则线程B就循环执行某段程序，否则线程B退出执行逻辑。
    我们来看一下这样一段代码，如图1所示：
   ![图1.Problem demo](https://raw.githubusercontent.com/river-and-boat/jmm/main/Demo.jpg)
    我们希望当线程A修改flag变量为true以后，线程B可以退出while循环并打印"End B"，但实际情况是线程B无法退出while循环。
    当在变量flag前加上volatile关键字后，可以满足我们的需求。

    那么，为什么会出现这种情况呢，volatile关键字到底帮助我们做了什么，其底层如何运作，下面让我们来一探究竟。

### 1. CPU工作内存的诞生
    在正式开始本文主题前，我们先来看一下CPU的结构。
    一开始，CPU是和我们主内存直接交互的。但是由于CPU的运算速度远大于内存的读写速度，这样会使CPU花费很长的时间等待数据从内存加载或将数据写入内存。
    于是，我们在CPU中为每个核都增加了自己的工作内存。
    有了CPU工作内存，我们就可以适配CPU的运算速度，减少处理器访问内存所需的时延和CPU的等待时间，提高CPU的利用率。多核并发下CPU的缓存架构如图2所示。
   ![图2.多核并发缓存架构](https://github.com/river-and-boat/jmm/blob/main/%E5%A4%9A%E6%A0%B8%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84.png)
    如图1所示，当CPU从主内存读取数据时，数据会被存储到其对应的CPU工作内存中，之后对数据的访问均从CPU工作内存中读取，当CPU对数据修改时，也将数据先写入工作内存，再由工作内存将数据写入主内存中。

### 2. JAVA内存模型
    在JAVA中，模仿上述CPU的缓存模型，也建立了相应的JAVA内存模型(JAVA Memory Model, JMM)，其工作原理如图3所示。
   ![图3.JAVA内存模型JMM](https://github.com/river-and-boat/jmm/blob/main/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)
    由图3可知，JMM针对JAVA线程之间的通信进行控制。
    JMM定义了线程与主内存之间的抽象关系，即：线程之间共享的变量存储在主内存中(也叫共享变量)。同时，每个线程都有一个工作内存，仅自己可以访问，其中存储了共享变量副本。
    明白了JAVA内存模型，我们就可以大概理解前述问题是怎么产生的了：
    1. 当线程B第一次访问共享变量flag时，它将flag从主内存读出，并存入自己的工作内存中（flag = false）
    2. 每一次while循环判断时，它都从自己的工作内存中直接读取flag(缓存命中)，因此flag总是为false
    3. 线程A修改flag的值，首先它将值从共享内存中读出，存储到自己的工作内存中（flag = false）
    4. 线程A将值修改为true，此时线程A工作内存中flag值变为true，但这对于线程B是不可感知的(不可见)
    5. 线程A将值写入回主内存，此时主内存的值已经更新了，但是由于线程B一直未更新自己的工作内存，因此无法结束while循环。

### 3. JMM数据原子操作
    根据上述第二节描述，在各线程读取、修改共享变量过程中，涉及了很多读操作，写操作，赋值操作等，而JMM在最底层都将它们封装成了一系列的数据原子操作。
    这些原子操作负责：
    1. 如何从主内存/共享内存读取数据
    2. 如何修改数据
    3. 修改完成后，数据如何写回主内存/共享内存
    ......
    那么下面我们来看一下这些原子操作及其作用：
    1. read(读取)：从主内存读取数据；
    2. load(载入)：将主内存读取到的数据写入工作内存；
    3. use(使用)：从工作内存读取数据用于计算；
    4. assign(赋值)：将计算好的值重新赋值到工作内存中；
    5. store(存储)：将工作内存中的值写入主内存；
    6. write(写入)：将store进主内存的数据赋值给主内存中对应的变量；
    7. lock(锁定)：将主内存共享变量加锁，标识为线程独占状态；
    8. unlock(解锁)：将主内存共享变量解锁，解锁后其他线程可以锁定该变量并进行赋值操作。

    那么，现在我们针对文章开始抛出的问题，将以上原子操作进行相应的代入，可以得到如图4所示的JMM内存模型。
   ![图4. JMM原子操作](https://github.com/river-and-boat/jmm/blob/main/JMM%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C.png)

    由图4我们可以更清楚地了解到问题所在。
    线程B从共享内存中[read]到flag的值后，将其[load]到工作内存中。线程B的执行殷勤通过[use]操作从工作内存使用flag的值。
    线程A执行引擎同样通过[read]、[load]、[use]拿到flag的值，修改完flag的值为true后，通过[assign]将新值更新到工作内存。
    同时，工作内存通过[store]、[write]方式将新值写回主内存的flag变量。
    需要注意两点：
    1. 在进行步骤6 store前需要加锁，以防止多个线程同时更新主内存的flag，在更新完成后解锁。
    2. 步骤6 store和步骤7 write的区别是：步骤6 store只负责将新值写回主内存，步骤7 write负责将新值赋值给主内存的flag变量。

### 4. volatile保证可见性
    那么volatile是如何解决上述问题的呢，为什么在flag变量前用volatile进行修饰，就可以解决以上问题呢，下面我们来一探究竟。
    我们都知道，任何高级语言，其底层都会转换为汇编语言进行执行，那么，我们先来看一下我们在变量前不加volatile关键字与加上后，它的汇编代码有什么变化。
    图5(1)所示为不加volatile关键字生成的汇编代码，可以看到方法executeThreadA()的25行正好是我们flag=true的赋值操作；
   ![图5(1) 不加volatile的汇编代码](https://github.com/river-and-boat/jmm/blob/main/%E4%B8%8D%E5%8A%A0volatile%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png)
    图5(2)所示为加上volatile关键字后生成的汇编代码。
   ![图5(2) 加上volatile的汇编代码](https://github.com/river-and-boat/jmm/blob/main/%E5%8A%A0%E4%B8%8Avolatile%E7%9A%84%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png)
    可以看到明显的区别是，加上volatile关键字后，在进行变量赋值操作时，指令增加了lock前缀。
    查略汇编相关手册(intel 64-ia-32-architectures-software-developer-instruction-set-reference-manual)对lock指令的解释，可以知道该lock前缀的作用：
    1. 当前CPU工作内存中的相应数据会被立即写回到主内存；
    2. 步骤1中写回主内存的操作会引起其他CPU里缓存了该内存地址的数据无效(MESI协议 https://www.cnblogs.com/yanlong300/p/8986041.html)

    现在我们可以很好的利用volatile关键字解决多核环境下数据可见性问题。现在我们补充图4中的相应步骤，更详细的展示在有volatile关键字时，JMM如何工作，如图6所示。
   ![图6. volatile关键字修饰的JMM](https://github.com/river-and-boat/jmm/blob/main/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E7%9A%84JMM.png)
    如图6所示，当在变量flag上增加volatile关键字时，线程A对flag进行修改后，会立即调用store和write操作，将数据写回主线程。
    同时，线程A会通过总线告诉其他线程，flag被我更新了。
    其他线程会通过CPU总线嗅探机制对总线进行监听，当收到来自总线的广播后，会去检查自己的工作内存中是否存在对应的变量，如果存在，则会将该变量置为无效。
    这样，当线程B再次访问该变量时，由于工作内存中的缓存已经失效，因此它会重新从主内存中读取该变量，并重复1、2、3步，以保证数据一致性。

### 5. volatile能否保证原子性
    前述内容我们探讨了volatile如何保证了数据的可见性，最后我们来看一下，volatile能否保证原子性。
    我们先来看一段原子性demo，如图7所示。
   ![图7. volatile原子性demo](https://github.com/river-and-boat/jmm/blob/main/volatile%E5%8E%9F%E5%AD%90%E6%80%A7demo.jpg)
    由图7可知，我们首先定义了共享变量count，并将其用volatile修饰。然后定义了10个线程，每个线程中都执行1000次循环，对count进行递增，我们希望得到的结果是10000，但多次运行后发现，结果总是小于等于10000的，如果对increate方法增加synchronized关键字修饰，或者直接使用JAVA自带的AtomicInteger原子类，则运行结果总是等于10000，这说明volatile并不能保证原子性。

#### 原因分析：
    让我们将目光再次聚焦到图6所示JMM内存模型，并进行原因分析。
    我们将图7所示的程序进行拆解并代入图6中：
    现在我们有十个线程，我们拿其中两个线程A、B为例，看一下为什么volatile不能保证原子性：
    1. A、B线程同时从主内存读取数据(count = 0)并加载到自己的工作内存中；
    2. A、B线程同时开始自己的第一次for循环，修改count值(此时A、B的工作内存的count的值均为1)，并立即回写入主内存(volatile特性)；
    3. 由于线程A、B同时向主内存写入数据，因此需要在store和write前加锁，两个线程竞争，我们假设线程A得到了锁；
    4. A线程修改主内存数据(count = 1)，并通过总线发送修改count事件；
    5. B线程通过CPU的总线嗅探机制，了解到了count变量的变化，并将自己工作内存中的count变量置为失效；
    6. 线程B在第二次for循环时，由于第一次的count值已经失效了，因此需要重新去主内存读取，此时读取的值是步骤4中A线程向主内存写入的值(count = 1)
    7. B线程执行count++操作，count = 2
    此时我们可以发现问题，在上述步骤中，我们一共执行了三次count++操作，但是count = 2，这是因为B线程中有一次count++操作被失效了，这就导致了最终的结果总是小于等于10000的。

### 总结
    至此，我们通过volatile关键字，了解到了与其相关的JMM的可见性和原子性，明白了JMM的结构图，以及volatile在底层是如何工作的。
    其实，JMM除了以上所提两个特性外，还有另一个特性：有序性，由于篇幅原因，我们这里不做过多讲述，下次再见！



    
